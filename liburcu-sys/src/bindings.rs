#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)] // u128 aren't actually abi safe, but there isn't a better option

/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const URCU_ARCH_X86: u32 = 1;
pub const URCU_ARCH_AMD64: u32 = 1;
pub const CONFIG_RCU_SMP: u32 = 1;
pub const CONFIG_RCU_TLS: u32 = 1;
pub const CONFIG_RCU_HAVE_CLOCK_GETTIME: u32 = 1;
pub const CONFIG_RCU_HAVE_MULTIFLAVOR: u32 = 1;
pub const _SYSCALL_H: u32 = 1;
pub const __X32_SYSCALL_BIT: u32 = 1073741824;
pub const __NR_read: u32 = 0;
pub const __NR_write: u32 = 1;
pub const __NR_open: u32 = 2;
pub const __NR_close: u32 = 3;
pub const __NR_stat: u32 = 4;
pub const __NR_fstat: u32 = 5;
pub const __NR_lstat: u32 = 6;
pub const __NR_poll: u32 = 7;
pub const __NR_lseek: u32 = 8;
pub const __NR_mmap: u32 = 9;
pub const __NR_mprotect: u32 = 10;
pub const __NR_munmap: u32 = 11;
pub const __NR_brk: u32 = 12;
pub const __NR_rt_sigaction: u32 = 13;
pub const __NR_rt_sigprocmask: u32 = 14;
pub const __NR_rt_sigreturn: u32 = 15;
pub const __NR_ioctl: u32 = 16;
pub const __NR_pread64: u32 = 17;
pub const __NR_pwrite64: u32 = 18;
pub const __NR_readv: u32 = 19;
pub const __NR_writev: u32 = 20;
pub const __NR_access: u32 = 21;
pub const __NR_pipe: u32 = 22;
pub const __NR_select: u32 = 23;
pub const __NR_sched_yield: u32 = 24;
pub const __NR_mremap: u32 = 25;
pub const __NR_msync: u32 = 26;
pub const __NR_mincore: u32 = 27;
pub const __NR_madvise: u32 = 28;
pub const __NR_shmget: u32 = 29;
pub const __NR_shmat: u32 = 30;
pub const __NR_shmctl: u32 = 31;
pub const __NR_dup: u32 = 32;
pub const __NR_dup2: u32 = 33;
pub const __NR_pause: u32 = 34;
pub const __NR_nanosleep: u32 = 35;
pub const __NR_getitimer: u32 = 36;
pub const __NR_alarm: u32 = 37;
pub const __NR_setitimer: u32 = 38;
pub const __NR_getpid: u32 = 39;
pub const __NR_sendfile: u32 = 40;
pub const __NR_socket: u32 = 41;
pub const __NR_connect: u32 = 42;
pub const __NR_accept: u32 = 43;
pub const __NR_sendto: u32 = 44;
pub const __NR_recvfrom: u32 = 45;
pub const __NR_sendmsg: u32 = 46;
pub const __NR_recvmsg: u32 = 47;
pub const __NR_shutdown: u32 = 48;
pub const __NR_bind: u32 = 49;
pub const __NR_listen: u32 = 50;
pub const __NR_getsockname: u32 = 51;
pub const __NR_getpeername: u32 = 52;
pub const __NR_socketpair: u32 = 53;
pub const __NR_setsockopt: u32 = 54;
pub const __NR_getsockopt: u32 = 55;
pub const __NR_clone: u32 = 56;
pub const __NR_fork: u32 = 57;
pub const __NR_vfork: u32 = 58;
pub const __NR_execve: u32 = 59;
pub const __NR_exit: u32 = 60;
pub const __NR_wait4: u32 = 61;
pub const __NR_kill: u32 = 62;
pub const __NR_uname: u32 = 63;
pub const __NR_semget: u32 = 64;
pub const __NR_semop: u32 = 65;
pub const __NR_semctl: u32 = 66;
pub const __NR_shmdt: u32 = 67;
pub const __NR_msgget: u32 = 68;
pub const __NR_msgsnd: u32 = 69;
pub const __NR_msgrcv: u32 = 70;
pub const __NR_msgctl: u32 = 71;
pub const __NR_fcntl: u32 = 72;
pub const __NR_flock: u32 = 73;
pub const __NR_fsync: u32 = 74;
pub const __NR_fdatasync: u32 = 75;
pub const __NR_truncate: u32 = 76;
pub const __NR_ftruncate: u32 = 77;
pub const __NR_getdents: u32 = 78;
pub const __NR_getcwd: u32 = 79;
pub const __NR_chdir: u32 = 80;
pub const __NR_fchdir: u32 = 81;
pub const __NR_rename: u32 = 82;
pub const __NR_mkdir: u32 = 83;
pub const __NR_rmdir: u32 = 84;
pub const __NR_creat: u32 = 85;
pub const __NR_link: u32 = 86;
pub const __NR_unlink: u32 = 87;
pub const __NR_symlink: u32 = 88;
pub const __NR_readlink: u32 = 89;
pub const __NR_chmod: u32 = 90;
pub const __NR_fchmod: u32 = 91;
pub const __NR_chown: u32 = 92;
pub const __NR_fchown: u32 = 93;
pub const __NR_lchown: u32 = 94;
pub const __NR_umask: u32 = 95;
pub const __NR_gettimeofday: u32 = 96;
pub const __NR_getrlimit: u32 = 97;
pub const __NR_getrusage: u32 = 98;
pub const __NR_sysinfo: u32 = 99;
pub const __NR_times: u32 = 100;
pub const __NR_ptrace: u32 = 101;
pub const __NR_getuid: u32 = 102;
pub const __NR_syslog: u32 = 103;
pub const __NR_getgid: u32 = 104;
pub const __NR_setuid: u32 = 105;
pub const __NR_setgid: u32 = 106;
pub const __NR_geteuid: u32 = 107;
pub const __NR_getegid: u32 = 108;
pub const __NR_setpgid: u32 = 109;
pub const __NR_getppid: u32 = 110;
pub const __NR_getpgrp: u32 = 111;
pub const __NR_setsid: u32 = 112;
pub const __NR_setreuid: u32 = 113;
pub const __NR_setregid: u32 = 114;
pub const __NR_getgroups: u32 = 115;
pub const __NR_setgroups: u32 = 116;
pub const __NR_setresuid: u32 = 117;
pub const __NR_getresuid: u32 = 118;
pub const __NR_setresgid: u32 = 119;
pub const __NR_getresgid: u32 = 120;
pub const __NR_getpgid: u32 = 121;
pub const __NR_setfsuid: u32 = 122;
pub const __NR_setfsgid: u32 = 123;
pub const __NR_getsid: u32 = 124;
pub const __NR_capget: u32 = 125;
pub const __NR_capset: u32 = 126;
pub const __NR_rt_sigpending: u32 = 127;
pub const __NR_rt_sigtimedwait: u32 = 128;
pub const __NR_rt_sigqueueinfo: u32 = 129;
pub const __NR_rt_sigsuspend: u32 = 130;
pub const __NR_sigaltstack: u32 = 131;
pub const __NR_utime: u32 = 132;
pub const __NR_mknod: u32 = 133;
pub const __NR_uselib: u32 = 134;
pub const __NR_personality: u32 = 135;
pub const __NR_ustat: u32 = 136;
pub const __NR_statfs: u32 = 137;
pub const __NR_fstatfs: u32 = 138;
pub const __NR_sysfs: u32 = 139;
pub const __NR_getpriority: u32 = 140;
pub const __NR_setpriority: u32 = 141;
pub const __NR_sched_setparam: u32 = 142;
pub const __NR_sched_getparam: u32 = 143;
pub const __NR_sched_setscheduler: u32 = 144;
pub const __NR_sched_getscheduler: u32 = 145;
pub const __NR_sched_get_priority_max: u32 = 146;
pub const __NR_sched_get_priority_min: u32 = 147;
pub const __NR_sched_rr_get_interval: u32 = 148;
pub const __NR_mlock: u32 = 149;
pub const __NR_munlock: u32 = 150;
pub const __NR_mlockall: u32 = 151;
pub const __NR_munlockall: u32 = 152;
pub const __NR_vhangup: u32 = 153;
pub const __NR_modify_ldt: u32 = 154;
pub const __NR_pivot_root: u32 = 155;
pub const __NR__sysctl: u32 = 156;
pub const __NR_prctl: u32 = 157;
pub const __NR_arch_prctl: u32 = 158;
pub const __NR_adjtimex: u32 = 159;
pub const __NR_setrlimit: u32 = 160;
pub const __NR_chroot: u32 = 161;
pub const __NR_sync: u32 = 162;
pub const __NR_acct: u32 = 163;
pub const __NR_settimeofday: u32 = 164;
pub const __NR_mount: u32 = 165;
pub const __NR_umount2: u32 = 166;
pub const __NR_swapon: u32 = 167;
pub const __NR_swapoff: u32 = 168;
pub const __NR_reboot: u32 = 169;
pub const __NR_sethostname: u32 = 170;
pub const __NR_setdomainname: u32 = 171;
pub const __NR_iopl: u32 = 172;
pub const __NR_ioperm: u32 = 173;
pub const __NR_create_module: u32 = 174;
pub const __NR_init_module: u32 = 175;
pub const __NR_delete_module: u32 = 176;
pub const __NR_get_kernel_syms: u32 = 177;
pub const __NR_query_module: u32 = 178;
pub const __NR_quotactl: u32 = 179;
pub const __NR_nfsservctl: u32 = 180;
pub const __NR_getpmsg: u32 = 181;
pub const __NR_putpmsg: u32 = 182;
pub const __NR_afs_syscall: u32 = 183;
pub const __NR_tuxcall: u32 = 184;
pub const __NR_security: u32 = 185;
pub const __NR_gettid: u32 = 186;
pub const __NR_readahead: u32 = 187;
pub const __NR_setxattr: u32 = 188;
pub const __NR_lsetxattr: u32 = 189;
pub const __NR_fsetxattr: u32 = 190;
pub const __NR_getxattr: u32 = 191;
pub const __NR_lgetxattr: u32 = 192;
pub const __NR_fgetxattr: u32 = 193;
pub const __NR_listxattr: u32 = 194;
pub const __NR_llistxattr: u32 = 195;
pub const __NR_flistxattr: u32 = 196;
pub const __NR_removexattr: u32 = 197;
pub const __NR_lremovexattr: u32 = 198;
pub const __NR_fremovexattr: u32 = 199;
pub const __NR_tkill: u32 = 200;
pub const __NR_time: u32 = 201;
pub const __NR_futex: u32 = 202;
pub const __NR_sched_setaffinity: u32 = 203;
pub const __NR_sched_getaffinity: u32 = 204;
pub const __NR_set_thread_area: u32 = 205;
pub const __NR_io_setup: u32 = 206;
pub const __NR_io_destroy: u32 = 207;
pub const __NR_io_getevents: u32 = 208;
pub const __NR_io_submit: u32 = 209;
pub const __NR_io_cancel: u32 = 210;
pub const __NR_get_thread_area: u32 = 211;
pub const __NR_lookup_dcookie: u32 = 212;
pub const __NR_epoll_create: u32 = 213;
pub const __NR_epoll_ctl_old: u32 = 214;
pub const __NR_epoll_wait_old: u32 = 215;
pub const __NR_remap_file_pages: u32 = 216;
pub const __NR_getdents64: u32 = 217;
pub const __NR_set_tid_address: u32 = 218;
pub const __NR_restart_syscall: u32 = 219;
pub const __NR_semtimedop: u32 = 220;
pub const __NR_fadvise64: u32 = 221;
pub const __NR_timer_create: u32 = 222;
pub const __NR_timer_settime: u32 = 223;
pub const __NR_timer_gettime: u32 = 224;
pub const __NR_timer_getoverrun: u32 = 225;
pub const __NR_timer_delete: u32 = 226;
pub const __NR_clock_settime: u32 = 227;
pub const __NR_clock_gettime: u32 = 228;
pub const __NR_clock_getres: u32 = 229;
pub const __NR_clock_nanosleep: u32 = 230;
pub const __NR_exit_group: u32 = 231;
pub const __NR_epoll_wait: u32 = 232;
pub const __NR_epoll_ctl: u32 = 233;
pub const __NR_tgkill: u32 = 234;
pub const __NR_utimes: u32 = 235;
pub const __NR_vserver: u32 = 236;
pub const __NR_mbind: u32 = 237;
pub const __NR_set_mempolicy: u32 = 238;
pub const __NR_get_mempolicy: u32 = 239;
pub const __NR_mq_open: u32 = 240;
pub const __NR_mq_unlink: u32 = 241;
pub const __NR_mq_timedsend: u32 = 242;
pub const __NR_mq_timedreceive: u32 = 243;
pub const __NR_mq_notify: u32 = 244;
pub const __NR_mq_getsetattr: u32 = 245;
pub const __NR_kexec_load: u32 = 246;
pub const __NR_waitid: u32 = 247;
pub const __NR_add_key: u32 = 248;
pub const __NR_request_key: u32 = 249;
pub const __NR_keyctl: u32 = 250;
pub const __NR_ioprio_set: u32 = 251;
pub const __NR_ioprio_get: u32 = 252;
pub const __NR_inotify_init: u32 = 253;
pub const __NR_inotify_add_watch: u32 = 254;
pub const __NR_inotify_rm_watch: u32 = 255;
pub const __NR_migrate_pages: u32 = 256;
pub const __NR_openat: u32 = 257;
pub const __NR_mkdirat: u32 = 258;
pub const __NR_mknodat: u32 = 259;
pub const __NR_fchownat: u32 = 260;
pub const __NR_futimesat: u32 = 261;
pub const __NR_newfstatat: u32 = 262;
pub const __NR_unlinkat: u32 = 263;
pub const __NR_renameat: u32 = 264;
pub const __NR_linkat: u32 = 265;
pub const __NR_symlinkat: u32 = 266;
pub const __NR_readlinkat: u32 = 267;
pub const __NR_fchmodat: u32 = 268;
pub const __NR_faccessat: u32 = 269;
pub const __NR_pselect6: u32 = 270;
pub const __NR_ppoll: u32 = 271;
pub const __NR_unshare: u32 = 272;
pub const __NR_set_robust_list: u32 = 273;
pub const __NR_get_robust_list: u32 = 274;
pub const __NR_splice: u32 = 275;
pub const __NR_tee: u32 = 276;
pub const __NR_sync_file_range: u32 = 277;
pub const __NR_vmsplice: u32 = 278;
pub const __NR_move_pages: u32 = 279;
pub const __NR_utimensat: u32 = 280;
pub const __NR_epoll_pwait: u32 = 281;
pub const __NR_signalfd: u32 = 282;
pub const __NR_timerfd_create: u32 = 283;
pub const __NR_eventfd: u32 = 284;
pub const __NR_fallocate: u32 = 285;
pub const __NR_timerfd_settime: u32 = 286;
pub const __NR_timerfd_gettime: u32 = 287;
pub const __NR_accept4: u32 = 288;
pub const __NR_signalfd4: u32 = 289;
pub const __NR_eventfd2: u32 = 290;
pub const __NR_epoll_create1: u32 = 291;
pub const __NR_dup3: u32 = 292;
pub const __NR_pipe2: u32 = 293;
pub const __NR_inotify_init1: u32 = 294;
pub const __NR_preadv: u32 = 295;
pub const __NR_pwritev: u32 = 296;
pub const __NR_rt_tgsigqueueinfo: u32 = 297;
pub const __NR_perf_event_open: u32 = 298;
pub const __NR_recvmmsg: u32 = 299;
pub const __NR_fanotify_init: u32 = 300;
pub const __NR_fanotify_mark: u32 = 301;
pub const __NR_prlimit64: u32 = 302;
pub const __NR_name_to_handle_at: u32 = 303;
pub const __NR_open_by_handle_at: u32 = 304;
pub const __NR_clock_adjtime: u32 = 305;
pub const __NR_syncfs: u32 = 306;
pub const __NR_sendmmsg: u32 = 307;
pub const __NR_setns: u32 = 308;
pub const __NR_getcpu: u32 = 309;
pub const __NR_process_vm_readv: u32 = 310;
pub const __NR_process_vm_writev: u32 = 311;
pub const __NR_kcmp: u32 = 312;
pub const __NR_finit_module: u32 = 313;
pub const __NR_sched_setattr: u32 = 314;
pub const __NR_sched_getattr: u32 = 315;
pub const __NR_renameat2: u32 = 316;
pub const __NR_seccomp: u32 = 317;
pub const __NR_getrandom: u32 = 318;
pub const __NR_memfd_create: u32 = 319;
pub const __NR_kexec_file_load: u32 = 320;
pub const __NR_bpf: u32 = 321;
pub const __NR_execveat: u32 = 322;
pub const __NR_userfaultfd: u32 = 323;
pub const __NR_membarrier: u32 = 324;
pub const __NR_mlock2: u32 = 325;
pub const __NR_copy_file_range: u32 = 326;
pub const __NR_preadv2: u32 = 327;
pub const __NR_pwritev2: u32 = 328;
pub const __NR_pkey_mprotect: u32 = 329;
pub const __NR_pkey_alloc: u32 = 330;
pub const __NR_pkey_free: u32 = 331;
pub const __NR_statx: u32 = 332;
pub const __NR_io_pgetevents: u32 = 333;
pub const __NR_rseq: u32 = 334;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __NR_cachestat: u32 = 451;
pub const __NR_fchmodat2: u32 = 452;
pub const __NR_map_shadow_stack: u32 = 453;
pub const __NR_futex_wake: u32 = 454;
pub const __NR_futex_wait: u32 = 455;
pub const __NR_futex_requeue: u32 = 456;
pub const __GLIBC_LINUX_VERSION_CODE: u32 = 395008;
pub const SYS__sysctl: u32 = 156;
pub const SYS_accept: u32 = 43;
pub const SYS_accept4: u32 = 288;
pub const SYS_access: u32 = 21;
pub const SYS_acct: u32 = 163;
pub const SYS_add_key: u32 = 248;
pub const SYS_adjtimex: u32 = 159;
pub const SYS_afs_syscall: u32 = 183;
pub const SYS_alarm: u32 = 37;
pub const SYS_arch_prctl: u32 = 158;
pub const SYS_bind: u32 = 49;
pub const SYS_bpf: u32 = 321;
pub const SYS_brk: u32 = 12;
pub const SYS_cachestat: u32 = 451;
pub const SYS_capget: u32 = 125;
pub const SYS_capset: u32 = 126;
pub const SYS_chdir: u32 = 80;
pub const SYS_chmod: u32 = 90;
pub const SYS_chown: u32 = 92;
pub const SYS_chroot: u32 = 161;
pub const SYS_clock_adjtime: u32 = 305;
pub const SYS_clock_getres: u32 = 229;
pub const SYS_clock_gettime: u32 = 228;
pub const SYS_clock_nanosleep: u32 = 230;
pub const SYS_clock_settime: u32 = 227;
pub const SYS_clone: u32 = 56;
pub const SYS_clone3: u32 = 435;
pub const SYS_close: u32 = 3;
pub const SYS_close_range: u32 = 436;
pub const SYS_connect: u32 = 42;
pub const SYS_copy_file_range: u32 = 326;
pub const SYS_creat: u32 = 85;
pub const SYS_create_module: u32 = 174;
pub const SYS_delete_module: u32 = 176;
pub const SYS_dup: u32 = 32;
pub const SYS_dup2: u32 = 33;
pub const SYS_dup3: u32 = 292;
pub const SYS_epoll_create: u32 = 213;
pub const SYS_epoll_create1: u32 = 291;
pub const SYS_epoll_ctl: u32 = 233;
pub const SYS_epoll_ctl_old: u32 = 214;
pub const SYS_epoll_pwait: u32 = 281;
pub const SYS_epoll_pwait2: u32 = 441;
pub const SYS_epoll_wait: u32 = 232;
pub const SYS_epoll_wait_old: u32 = 215;
pub const SYS_eventfd: u32 = 284;
pub const SYS_eventfd2: u32 = 290;
pub const SYS_execve: u32 = 59;
pub const SYS_execveat: u32 = 322;
pub const SYS_exit: u32 = 60;
pub const SYS_exit_group: u32 = 231;
pub const SYS_faccessat: u32 = 269;
pub const SYS_faccessat2: u32 = 439;
pub const SYS_fadvise64: u32 = 221;
pub const SYS_fallocate: u32 = 285;
pub const SYS_fanotify_init: u32 = 300;
pub const SYS_fanotify_mark: u32 = 301;
pub const SYS_fchdir: u32 = 81;
pub const SYS_fchmod: u32 = 91;
pub const SYS_fchmodat: u32 = 268;
pub const SYS_fchmodat2: u32 = 452;
pub const SYS_fchown: u32 = 93;
pub const SYS_fchownat: u32 = 260;
pub const SYS_fcntl: u32 = 72;
pub const SYS_fdatasync: u32 = 75;
pub const SYS_fgetxattr: u32 = 193;
pub const SYS_finit_module: u32 = 313;
pub const SYS_flistxattr: u32 = 196;
pub const SYS_flock: u32 = 73;
pub const SYS_fork: u32 = 57;
pub const SYS_fremovexattr: u32 = 199;
pub const SYS_fsconfig: u32 = 431;
pub const SYS_fsetxattr: u32 = 190;
pub const SYS_fsmount: u32 = 432;
pub const SYS_fsopen: u32 = 430;
pub const SYS_fspick: u32 = 433;
pub const SYS_fstat: u32 = 5;
pub const SYS_fstatfs: u32 = 138;
pub const SYS_fsync: u32 = 74;
pub const SYS_ftruncate: u32 = 77;
pub const SYS_futex: u32 = 202;
pub const SYS_futex_requeue: u32 = 456;
pub const SYS_futex_wait: u32 = 455;
pub const SYS_futex_waitv: u32 = 449;
pub const SYS_futex_wake: u32 = 454;
pub const SYS_futimesat: u32 = 261;
pub const SYS_get_kernel_syms: u32 = 177;
pub const SYS_get_mempolicy: u32 = 239;
pub const SYS_get_robust_list: u32 = 274;
pub const SYS_get_thread_area: u32 = 211;
pub const SYS_getcpu: u32 = 309;
pub const SYS_getcwd: u32 = 79;
pub const SYS_getdents: u32 = 78;
pub const SYS_getdents64: u32 = 217;
pub const SYS_getegid: u32 = 108;
pub const SYS_geteuid: u32 = 107;
pub const SYS_getgid: u32 = 104;
pub const SYS_getgroups: u32 = 115;
pub const SYS_getitimer: u32 = 36;
pub const SYS_getpeername: u32 = 52;
pub const SYS_getpgid: u32 = 121;
pub const SYS_getpgrp: u32 = 111;
pub const SYS_getpid: u32 = 39;
pub const SYS_getpmsg: u32 = 181;
pub const SYS_getppid: u32 = 110;
pub const SYS_getpriority: u32 = 140;
pub const SYS_getrandom: u32 = 318;
pub const SYS_getresgid: u32 = 120;
pub const SYS_getresuid: u32 = 118;
pub const SYS_getrlimit: u32 = 97;
pub const SYS_getrusage: u32 = 98;
pub const SYS_getsid: u32 = 124;
pub const SYS_getsockname: u32 = 51;
pub const SYS_getsockopt: u32 = 55;
pub const SYS_gettid: u32 = 186;
pub const SYS_gettimeofday: u32 = 96;
pub const SYS_getuid: u32 = 102;
pub const SYS_getxattr: u32 = 191;
pub const SYS_init_module: u32 = 175;
pub const SYS_inotify_add_watch: u32 = 254;
pub const SYS_inotify_init: u32 = 253;
pub const SYS_inotify_init1: u32 = 294;
pub const SYS_inotify_rm_watch: u32 = 255;
pub const SYS_io_cancel: u32 = 210;
pub const SYS_io_destroy: u32 = 207;
pub const SYS_io_getevents: u32 = 208;
pub const SYS_io_pgetevents: u32 = 333;
pub const SYS_io_setup: u32 = 206;
pub const SYS_io_submit: u32 = 209;
pub const SYS_io_uring_enter: u32 = 426;
pub const SYS_io_uring_register: u32 = 427;
pub const SYS_io_uring_setup: u32 = 425;
pub const SYS_ioctl: u32 = 16;
pub const SYS_ioperm: u32 = 173;
pub const SYS_iopl: u32 = 172;
pub const SYS_ioprio_get: u32 = 252;
pub const SYS_ioprio_set: u32 = 251;
pub const SYS_kcmp: u32 = 312;
pub const SYS_kexec_file_load: u32 = 320;
pub const SYS_kexec_load: u32 = 246;
pub const SYS_keyctl: u32 = 250;
pub const SYS_kill: u32 = 62;
pub const SYS_landlock_add_rule: u32 = 445;
pub const SYS_landlock_create_ruleset: u32 = 444;
pub const SYS_landlock_restrict_self: u32 = 446;
pub const SYS_lchown: u32 = 94;
pub const SYS_lgetxattr: u32 = 192;
pub const SYS_link: u32 = 86;
pub const SYS_linkat: u32 = 265;
pub const SYS_listen: u32 = 50;
pub const SYS_listxattr: u32 = 194;
pub const SYS_llistxattr: u32 = 195;
pub const SYS_lookup_dcookie: u32 = 212;
pub const SYS_lremovexattr: u32 = 198;
pub const SYS_lseek: u32 = 8;
pub const SYS_lsetxattr: u32 = 189;
pub const SYS_lstat: u32 = 6;
pub const SYS_madvise: u32 = 28;
pub const SYS_map_shadow_stack: u32 = 453;
pub const SYS_mbind: u32 = 237;
pub const SYS_membarrier: u32 = 324;
pub const SYS_memfd_create: u32 = 319;
pub const SYS_memfd_secret: u32 = 447;
pub const SYS_migrate_pages: u32 = 256;
pub const SYS_mincore: u32 = 27;
pub const SYS_mkdir: u32 = 83;
pub const SYS_mkdirat: u32 = 258;
pub const SYS_mknod: u32 = 133;
pub const SYS_mknodat: u32 = 259;
pub const SYS_mlock: u32 = 149;
pub const SYS_mlock2: u32 = 325;
pub const SYS_mlockall: u32 = 151;
pub const SYS_mmap: u32 = 9;
pub const SYS_modify_ldt: u32 = 154;
pub const SYS_mount: u32 = 165;
pub const SYS_mount_setattr: u32 = 442;
pub const SYS_move_mount: u32 = 429;
pub const SYS_move_pages: u32 = 279;
pub const SYS_mprotect: u32 = 10;
pub const SYS_mq_getsetattr: u32 = 245;
pub const SYS_mq_notify: u32 = 244;
pub const SYS_mq_open: u32 = 240;
pub const SYS_mq_timedreceive: u32 = 243;
pub const SYS_mq_timedsend: u32 = 242;
pub const SYS_mq_unlink: u32 = 241;
pub const SYS_mremap: u32 = 25;
pub const SYS_msgctl: u32 = 71;
pub const SYS_msgget: u32 = 68;
pub const SYS_msgrcv: u32 = 70;
pub const SYS_msgsnd: u32 = 69;
pub const SYS_msync: u32 = 26;
pub const SYS_munlock: u32 = 150;
pub const SYS_munlockall: u32 = 152;
pub const SYS_munmap: u32 = 11;
pub const SYS_name_to_handle_at: u32 = 303;
pub const SYS_nanosleep: u32 = 35;
pub const SYS_newfstatat: u32 = 262;
pub const SYS_nfsservctl: u32 = 180;
pub const SYS_open: u32 = 2;
pub const SYS_open_by_handle_at: u32 = 304;
pub const SYS_open_tree: u32 = 428;
pub const SYS_openat: u32 = 257;
pub const SYS_openat2: u32 = 437;
pub const SYS_pause: u32 = 34;
pub const SYS_perf_event_open: u32 = 298;
pub const SYS_personality: u32 = 135;
pub const SYS_pidfd_getfd: u32 = 438;
pub const SYS_pidfd_open: u32 = 434;
pub const SYS_pidfd_send_signal: u32 = 424;
pub const SYS_pipe: u32 = 22;
pub const SYS_pipe2: u32 = 293;
pub const SYS_pivot_root: u32 = 155;
pub const SYS_pkey_alloc: u32 = 330;
pub const SYS_pkey_free: u32 = 331;
pub const SYS_pkey_mprotect: u32 = 329;
pub const SYS_poll: u32 = 7;
pub const SYS_ppoll: u32 = 271;
pub const SYS_prctl: u32 = 157;
pub const SYS_pread64: u32 = 17;
pub const SYS_preadv: u32 = 295;
pub const SYS_preadv2: u32 = 327;
pub const SYS_prlimit64: u32 = 302;
pub const SYS_process_madvise: u32 = 440;
pub const SYS_process_mrelease: u32 = 448;
pub const SYS_process_vm_readv: u32 = 310;
pub const SYS_process_vm_writev: u32 = 311;
pub const SYS_pselect6: u32 = 270;
pub const SYS_ptrace: u32 = 101;
pub const SYS_putpmsg: u32 = 182;
pub const SYS_pwrite64: u32 = 18;
pub const SYS_pwritev: u32 = 296;
pub const SYS_pwritev2: u32 = 328;
pub const SYS_query_module: u32 = 178;
pub const SYS_quotactl: u32 = 179;
pub const SYS_quotactl_fd: u32 = 443;
pub const SYS_read: u32 = 0;
pub const SYS_readahead: u32 = 187;
pub const SYS_readlink: u32 = 89;
pub const SYS_readlinkat: u32 = 267;
pub const SYS_readv: u32 = 19;
pub const SYS_reboot: u32 = 169;
pub const SYS_recvfrom: u32 = 45;
pub const SYS_recvmmsg: u32 = 299;
pub const SYS_recvmsg: u32 = 47;
pub const SYS_remap_file_pages: u32 = 216;
pub const SYS_removexattr: u32 = 197;
pub const SYS_rename: u32 = 82;
pub const SYS_renameat: u32 = 264;
pub const SYS_renameat2: u32 = 316;
pub const SYS_request_key: u32 = 249;
pub const SYS_restart_syscall: u32 = 219;
pub const SYS_rmdir: u32 = 84;
pub const SYS_rseq: u32 = 334;
pub const SYS_rt_sigaction: u32 = 13;
pub const SYS_rt_sigpending: u32 = 127;
pub const SYS_rt_sigprocmask: u32 = 14;
pub const SYS_rt_sigqueueinfo: u32 = 129;
pub const SYS_rt_sigreturn: u32 = 15;
pub const SYS_rt_sigsuspend: u32 = 130;
pub const SYS_rt_sigtimedwait: u32 = 128;
pub const SYS_rt_tgsigqueueinfo: u32 = 297;
pub const SYS_sched_get_priority_max: u32 = 146;
pub const SYS_sched_get_priority_min: u32 = 147;
pub const SYS_sched_getaffinity: u32 = 204;
pub const SYS_sched_getattr: u32 = 315;
pub const SYS_sched_getparam: u32 = 143;
pub const SYS_sched_getscheduler: u32 = 145;
pub const SYS_sched_rr_get_interval: u32 = 148;
pub const SYS_sched_setaffinity: u32 = 203;
pub const SYS_sched_setattr: u32 = 314;
pub const SYS_sched_setparam: u32 = 142;
pub const SYS_sched_setscheduler: u32 = 144;
pub const SYS_sched_yield: u32 = 24;
pub const SYS_seccomp: u32 = 317;
pub const SYS_security: u32 = 185;
pub const SYS_select: u32 = 23;
pub const SYS_semctl: u32 = 66;
pub const SYS_semget: u32 = 64;
pub const SYS_semop: u32 = 65;
pub const SYS_semtimedop: u32 = 220;
pub const SYS_sendfile: u32 = 40;
pub const SYS_sendmmsg: u32 = 307;
pub const SYS_sendmsg: u32 = 46;
pub const SYS_sendto: u32 = 44;
pub const SYS_set_mempolicy: u32 = 238;
pub const SYS_set_mempolicy_home_node: u32 = 450;
pub const SYS_set_robust_list: u32 = 273;
pub const SYS_set_thread_area: u32 = 205;
pub const SYS_set_tid_address: u32 = 218;
pub const SYS_setdomainname: u32 = 171;
pub const SYS_setfsgid: u32 = 123;
pub const SYS_setfsuid: u32 = 122;
pub const SYS_setgid: u32 = 106;
pub const SYS_setgroups: u32 = 116;
pub const SYS_sethostname: u32 = 170;
pub const SYS_setitimer: u32 = 38;
pub const SYS_setns: u32 = 308;
pub const SYS_setpgid: u32 = 109;
pub const SYS_setpriority: u32 = 141;
pub const SYS_setregid: u32 = 114;
pub const SYS_setresgid: u32 = 119;
pub const SYS_setresuid: u32 = 117;
pub const SYS_setreuid: u32 = 113;
pub const SYS_setrlimit: u32 = 160;
pub const SYS_setsid: u32 = 112;
pub const SYS_setsockopt: u32 = 54;
pub const SYS_settimeofday: u32 = 164;
pub const SYS_setuid: u32 = 105;
pub const SYS_setxattr: u32 = 188;
pub const SYS_shmat: u32 = 30;
pub const SYS_shmctl: u32 = 31;
pub const SYS_shmdt: u32 = 67;
pub const SYS_shmget: u32 = 29;
pub const SYS_shutdown: u32 = 48;
pub const SYS_sigaltstack: u32 = 131;
pub const SYS_signalfd: u32 = 282;
pub const SYS_signalfd4: u32 = 289;
pub const SYS_socket: u32 = 41;
pub const SYS_socketpair: u32 = 53;
pub const SYS_splice: u32 = 275;
pub const SYS_stat: u32 = 4;
pub const SYS_statfs: u32 = 137;
pub const SYS_statx: u32 = 332;
pub const SYS_swapoff: u32 = 168;
pub const SYS_swapon: u32 = 167;
pub const SYS_symlink: u32 = 88;
pub const SYS_symlinkat: u32 = 266;
pub const SYS_sync: u32 = 162;
pub const SYS_sync_file_range: u32 = 277;
pub const SYS_syncfs: u32 = 306;
pub const SYS_sysfs: u32 = 139;
pub const SYS_sysinfo: u32 = 99;
pub const SYS_syslog: u32 = 103;
pub const SYS_tee: u32 = 276;
pub const SYS_tgkill: u32 = 234;
pub const SYS_time: u32 = 201;
pub const SYS_timer_create: u32 = 222;
pub const SYS_timer_delete: u32 = 226;
pub const SYS_timer_getoverrun: u32 = 225;
pub const SYS_timer_gettime: u32 = 224;
pub const SYS_timer_settime: u32 = 223;
pub const SYS_timerfd_create: u32 = 283;
pub const SYS_timerfd_gettime: u32 = 287;
pub const SYS_timerfd_settime: u32 = 286;
pub const SYS_times: u32 = 100;
pub const SYS_tkill: u32 = 200;
pub const SYS_truncate: u32 = 76;
pub const SYS_tuxcall: u32 = 184;
pub const SYS_umask: u32 = 95;
pub const SYS_umount2: u32 = 166;
pub const SYS_uname: u32 = 63;
pub const SYS_unlink: u32 = 87;
pub const SYS_unlinkat: u32 = 263;
pub const SYS_unshare: u32 = 272;
pub const SYS_uselib: u32 = 134;
pub const SYS_userfaultfd: u32 = 323;
pub const SYS_ustat: u32 = 136;
pub const SYS_utime: u32 = 132;
pub const SYS_utimensat: u32 = 280;
pub const SYS_utimes: u32 = 235;
pub const SYS_vfork: u32 = 58;
pub const SYS_vhangup: u32 = 153;
pub const SYS_vmsplice: u32 = 278;
pub const SYS_vserver: u32 = 236;
pub const SYS_wait4: u32 = 61;
pub const SYS_waitid: u32 = 247;
pub const SYS_write: u32 = 1;
pub const SYS_writev: u32 = 20;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CAA_CACHE_LINE_SIZE: u32 = 128;
pub const CONFIG_RCU_HAVE_FENCE: u32 = 1;
pub const URCU_CALL_RCU_RT: u32 = 1;
pub const URCU_CALL_RCU_RUNNING: u32 = 2;
pub const URCU_CALL_RCU_STOP: u32 = 4;
pub const URCU_CALL_RCU_STOPPED: u32 = 8;
pub const URCU_CALL_RCU_PAUSE: u32 = 16;
pub const URCU_CALL_RCU_PAUSED: u32 = 32;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[doc = " Returned by `div'."]
#[repr(C)]
#[derive(Debug)]
pub struct div_t {
    #[doc = " Quotient."]
    pub quot: ::std::os::raw::c_int,
    #[doc = " Remainder."]
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct ldiv_t {
    #[doc = " Quotient."]
    pub quot: ::std::os::raw::c_long,
    #[doc = " Remainder."]
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[doc = " Returned by `lldiv'."]
#[repr(C)]
#[derive(Debug)]
pub struct lldiv_t {
    #[doc = " Quotient."]
    pub quot: ::std::os::raw::c_longlong,
    #[doc = " Remainder."]
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    #[doc = " Convert a string to a floating-point number."]
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[doc = " Convert a string to an integer."]
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a string to a long integer."]
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Convert a string to a long long integer."]
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to a floating-point number."]
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " Likewise for `float' and `long double' sizes of floating-point numbers."]
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    #[doc = " Convert a string to a long integer."]
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Convert a string to an unsigned long integer."]
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Convert a string to a quadword integer."]
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to an unsigned quadword integer."]
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " Convert a string to a quadword integer."]
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert a string to an unsigned quadword integer."]
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = " Convert N to base 64 using the digits \"./0-9A-Za-z\", least-significant\ndigit first.  Returns a pointer to static storage overwritten by the\nnext call."]
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read a number from a string S in base 64 as above."]
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
#[doc = " Convenience types."]
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
#[doc = " These few don't really vary by system, they always correspond\nto one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,\neven in the presence of asynchronous interrupts.\nIt is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
#[doc = " Returned by `clock'."]
pub type clock_t = __clock_t;
#[doc = " Clock ID used in clock and timer functions."]
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
#[doc = " Timer ID returned by `timer_create'."]
pub type timer_t = __timer_t;
#[doc = " Old compatibility names for C types."]
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
#[doc = " These were defined by ISO C without the first `_'."]
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[doc = " A set of signals to be blocked, unblocked, or waited for."]
pub type sigset_t = __sigset_t;
#[doc = " A time value that is accurate to the nearest\nmicrosecond but also has a range of years."]
#[repr(C)]
#[derive(Debug)]
pub struct timeval {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Microseconds."]
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[doc = " POSIX.1b structure for a time value.  This is like a `struct timeval' but\nhas nanoseconds instead of microseconds."]
#[repr(C)]
#[derive(Debug)]
pub struct timespec {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Nanoseconds."]
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
#[doc = " The fd_set member is required to be an array of longs."]
pub type __fd_mask = ::std::os::raw::c_long;
#[doc = " fd_set for select and pselect."]
#[repr(C)]
#[derive(Debug)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
#[doc = " Sometimes the fd_set member is assumed to have this type."]
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[doc = " Counter that is monotonically increasing (by less than 2**31 per\nincrement), with a single writer, and an arbitrary number of\nreaders."]
#[repr(C)]
pub struct __atomic_wide_counter {
    pub __value64: __BindgenUnionField<::std::os::raw::c_ulonglong>,
    pub __value32: __BindgenUnionField<__atomic_wide_counter__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[doc = " Common definition of pthread_mutex_t."]
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
#[doc = " Common definition of pthread_mutex_t."]
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    #[doc = " KIND must stay at this position in the structure to maintain\nbinary compatibility with static initializers."]
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    #[doc = " FLAGS must stay at this position in the structure to maintain\nbinary compatibility."]
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[doc = " Common definition of pthread_cond_t."]
#[repr(C)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
#[doc = " Thread identifiers.  The structure of the attribute type is not\nexposed on purpose."]
pub type pthread_t = ::std::os::raw::c_ulong;
#[doc = " Data structures for mutex handling.  The structure of the attribute\ntype is not exposed on purpose."]
#[repr(C)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " Data structure for condition variable handling.  The structure of\nthe attribute type is not exposed on purpose."]
#[repr(C)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " Keys for thread-specific data"]
pub type pthread_key_t = ::std::os::raw::c_uint;
#[doc = " Once-only execution"]
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<__pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<__pthread_cond_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " Data structure for reader-writer lock variable handling.  The\nstructure of the attribute type is deliberately not exposed."]
#[repr(C)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<__pthread_rwlock_arch_t>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[doc = " POSIX spinlock data type."]
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[doc = " POSIX barriers data type.  The structure of the type is\ndeliberately not exposed."]
#[repr(C)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    #[doc = " These are the functions that actually do things.  The `random', `srandom',\n`initstate' and `setstate' functions are those from BSD Unices.\nThe `rand' and `srand' functions are required by the ANSI standard.\nWe provide both interfaces to the same random number generator.  */\n/* Return a random long integer between 0 and 2^31-1 inclusive."]
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Seed the random number generator with the given number."]
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Initialize the random number generator to use state buffer STATEBUF,\nof length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,\n32, 64, 128 and 256, the bigger the better; values less than 8 will\ncause an error and values greater than 256 will be rounded down."]
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Switch the random number generator to state buffer STATEBUF,\nwhich should have been previously initialized by `initstate'."]
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[doc = " Reentrant versions of the `random' family of functions.\nThese functions all use the following data structure to contain\nstate, rather than global state variables."]
#[repr(C)]
#[derive(Debug)]
pub struct random_data {
    #[doc = " Front pointer."]
    pub fptr: *mut i32,
    #[doc = " Rear pointer."]
    pub rptr: *mut i32,
    #[doc = " Array of state values."]
    pub state: *mut i32,
    #[doc = " Type of random number generator."]
    pub rand_type: ::std::os::raw::c_int,
    #[doc = " Degree of random number generator."]
    pub rand_deg: ::std::os::raw::c_int,
    #[doc = " Distance between front and rear."]
    pub rand_sep: ::std::os::raw::c_int,
    #[doc = " Pointer behind state table."]
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a random integer between 0 and RAND_MAX inclusive."]
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seed the random number generator with the given number."]
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Reentrant interface according to POSIX.1."]
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return non-negative, double-precision floating-point value in [0.0,1.0)."]
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    #[doc = " Return non-negative, long integer in [0,2^31)."]
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Return signed, long integers in [-2^31,2^31)."]
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Seed random number generator."]
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[doc = " Data structure for communication with thread safe versions.  This\ntype is to be regarded as opaque.  It's only exported because users\nhave to allocate objects of this type."]
#[repr(C)]
#[derive(Debug)]
pub struct drand48_data {
    #[doc = " Current state."]
    pub __x: [::std::os::raw::c_ushort; 3usize],
    #[doc = " Old state."]
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    #[doc = " Additive const. in congruential formula."]
    pub __c: ::std::os::raw::c_ushort,
    #[doc = " Flag for initializing."]
    pub __init: ::std::os::raw::c_ushort,
    #[doc = " Factor in congruential\nformula."]
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    #[doc = " Return non-negative, double-precision floating-point value in [0.0,1.0)."]
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return non-negative, long integer in [0,2^31)."]
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return signed, long integers in [-2^31,2^31)."]
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seed random number generator."]
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a random integer between zero and 2**32-1 (inclusive)."]
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    #[doc = " Fill the buffer with random data."]
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    #[doc = " Return a random number between zero (inclusive) and the specified\nlimit (exclusive)."]
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    #[doc = " Allocate SIZE bytes of memory."]
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate NMEMB elements of SIZE bytes each, all initialized to 0."]
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Re-allocate the previously allocated block\nin PTR, making the new block SIZE bytes long.  */\n/* __attribute_malloc__ is not used, because if realloc returns\nthe same pointer that was passed to it, aliasing needs to be allowed\nbetween objects pointed by the old and new pointers."]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free a block allocated by `malloc', `realloc' or `calloc'."]
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Re-allocate the previously allocated block in PTR, making the new\nblock large enough for NMEMB elements of SIZE bytes each.  */\n/* __attribute_malloc__ is not used, because if reallocarray returns\nthe same pointer that was passed to it, aliasing needs to be allowed\nbetween objects pointed by the old and new pointers."]
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a block that will be freed when the calling function exits."]
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate SIZE bytes on a page boundary.  The storage cannot be freed."]
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate memory of SIZE bytes with an alignment of ALIGNMENT."]
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ISO C variant of aligned allocation."]
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Abort execution and generate a core-dump."]
    pub fn abort() -> !;
}
extern "C" {
    #[doc = " Register a function to be called when `exit' is called."]
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a function to be called with the status\ngiven to `exit' and the given argument."]
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call all functions registered with `atexit' and `on_exit',\nin the reverse of the order in which they were registered,\nperform stdio cleanup, and terminate program execution with STATUS."]
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Call all functions registered with `at_quick_exit' in the reverse\nof the order in which they were registered and terminate program\nexecution with STATUS."]
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Terminate the program with STATUS without calling any of the\nfunctions registered with `atexit' or `on_exit'."]
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[doc = " Return the value of envariable NAME, or NULL if it doesn't exist."]
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The SVID says this is in <stdio.h>, but this seems a better place.\t*/\n/* Put STRING, which is of the form \"NAME=VALUE\", in the environment.\nIf there is no `=', remove NAME from the environment."]
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set NAME to VALUE in the environment.\nIf REPLACE is nonzero, overwrite an existing value."]
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove the variable NAME from the environment."]
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The `clearenv' was planned to be added to POSIX.1 but probably\nnever made it.  Nevertheless the POSIX.9 standard (POSIX bindings\nfor Fortran 77) requires this function."]
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a unique temporary file name from TEMPLATE.\nThe last six characters of TEMPLATE must be \"XXXXXX\";\nthey are replaced with a string that makes the file name unique.\nAlways returns TEMPLATE, it's either a temporary file name or a null\nstring if it cannot get a unique file name."]
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a unique temporary directory from TEMPLATE.\nThe last six characters of TEMPLATE must be \"XXXXXX\";\nthey are replaced with a string that makes the directory name unique.\nReturns TEMPLATE, or a null pointer if it cannot get a unique name.\nThe directory is created mode 700."]
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Execute the given line as a shell command.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the canonical absolute name of file NAME.  If RESOLVED is\nnull, the result is malloc'd; otherwise, if the canonical name is\nPATH_MAX chars or more, returns null with `errno' set to\nENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,\nreturns the name in RESOLVED."]
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Do a binary search for KEY in BASE, which consists of NMEMB elements\nof SIZE bytes each, using COMPAR to perform the comparisons."]
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Sort NMEMB elements of BASE, of SIZE bytes each,\nusing COMPAR to perform the comparisons."]
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    #[doc = " Return the absolute value of X."]
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Return the `div_t', `ldiv_t' or `lldiv_t' representation\nof the value of NUMER over DENOM. */\n/* GCC may have built-ins for these someday."]
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    #[doc = " Convert VALUE to a string with NDIGIT digits and return a pointer to\nthis.  Set *DECPT with the position of the decimal character and *SIGN\nwith the sign of the number."]
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT\nwith the position of the decimal character and *SIGN with the sign of\nthe number."]
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " If possible convert VALUE to a string with NDIGIT significant digits.\nOtherwise use exponential representation.  The resulting string will\nbe written to BUF."]
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Long double versions of above functions."]
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Reentrant version of the functions above which provide their own\nbuffers."]
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the length of the multibyte character\nin S, which is no longer than N."]
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the length of the given multibyte character,\nputting its `wchar_t' representation in *PWC."]
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the multibyte character represented\nby WCHAR in S, returning its length."]
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a multibyte string to a wide char string."]
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    #[doc = " Convert a wide char string to multibyte string."]
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    #[doc = " Determine whether the string value of RESPONSE matches the affirmation\nor negative response expression as specified by the LC_MESSAGES category\nin the program's current locale.  Returns 1 if affirmative, 0 if\nnegative, and -1 if not matching."]
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse comma separated suboption from *OPTIONP and match against\nstrings in TOKENS.  If found return index and set *VALUEP to\noptional value introduced by an equal sign.  If the suboption is\nnot part of TOKENS return in *VALUEP beginning of unknown\nsuboption.  On exit *OPTIONP is set to the beginning of the next\ntoken or at the terminating NUL character."]
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put the 1 minute, 5 minute and 15 minute load averages into the first\nNELEM elements of LOADAVG.  Return the number written (never more than\nthree, but may be less than NELEM), or -1 if an error occurred."]
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[doc = " Data structure to describe a process' schedulability."]
#[repr(C)]
#[derive(Debug)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
#[doc = " Type for array elements in 'cpu_set_t'."]
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[doc = " Data structure to describe CPU mask."]
#[repr(C)]
#[derive(Debug)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    #[doc = " Set scheduling parameters for a process."]
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve scheduling parameters for a particular process."]
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling algorithm and/or parameters for a process."]
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve scheduling algorithm for a particular purpose."]
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Yield the processor."]
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get maximum priority value for a scheduler."]
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get minimum priority value for a scheduler."]
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
#[doc = " ISO C `broken-down time' structure."]
#[repr(C)]
#[derive(Debug)]
pub struct tm {
    #[doc = " Seconds.\t[0-60] (1 leap second)"]
    pub tm_sec: ::std::os::raw::c_int,
    #[doc = " Minutes.\t[0-59]"]
    pub tm_min: ::std::os::raw::c_int,
    #[doc = " Hours.\t[0-23]"]
    pub tm_hour: ::std::os::raw::c_int,
    #[doc = " Day.\t\t[1-31]"]
    pub tm_mday: ::std::os::raw::c_int,
    #[doc = " Month.\t[0-11]"]
    pub tm_mon: ::std::os::raw::c_int,
    #[doc = " Year\t- 1900."]
    pub tm_year: ::std::os::raw::c_int,
    #[doc = " Day of week.\t[0-6]"]
    pub tm_wday: ::std::os::raw::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: ::std::os::raw::c_int,
    #[doc = " DST.\t\t[-1/0/1]"]
    pub tm_isdst: ::std::os::raw::c_int,
    #[doc = " Seconds east of UTC."]
    pub tm_gmtoff: ::std::os::raw::c_long,
    #[doc = " Timezone abbreviation."]
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[doc = " POSIX.1b structure for timer start values and intervals."]
#[repr(C)]
#[derive(Debug)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[doc = " POSIX.1-2008: the locale_t type, representing a locale context\n(implementation-namespace version).  This type should be treated\nas opaque by applications; some details are exposed for the sake of\nefficiency in e.g. ctype functions."]
#[repr(C)]
#[derive(Debug)]
pub struct __locale_struct {
    #[doc = " 13 = __LC_LAST."]
    pub __locales: [*mut __locale_data; 13usize],
    #[doc = " To increase the speed of this solution we add some special members."]
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    #[doc = " Note: LC_ALL is not a valid index into this array."]
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    #[doc = " Time used by the program so far (user time + system time).\nThe result / CLOCKS_PER_SEC is program time in seconds."]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[doc = " Return the current time and put it in *TIMER if TIMER is not NULL."]
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    #[doc = " Return the difference between TIME1 and TIME0."]
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    #[doc = " Return the `time_t' representation of TP and normalize TP."]
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Format TP into S according to FORMAT.\nWrite no more than MAXSIZE characters and return the number\nof characters written, or 0 if it would exceed MAXSIZE."]
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    #[doc = " Similar to the two functions above but take the information from\nthe provided locale and not the global locale."]
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER\nin Universal Coordinated Time (aka Greenwich Mean Time)."]
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation\nof *TIMER in the local timezone."]
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in UTC,\nusing *TP to store the result."]
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in local time,\nusing *TP to store the result."]
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return in BUF a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Current time zone abbreviations."]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[doc = " If daylight-saving time is ever in use."]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seconds west of UTC."]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Same as above."]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[doc = " Set time conversion information from the TZ environment variable.\nIf TZ is not defined, a locale-dependent default is used."]
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Like `mktime', but for TP represents Universal Time, not local time."]
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Another name for `mktime'."]
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Return the number of days in YEAR."]
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pause execution for a number of nanoseconds.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get resolution of clock CLOCK_ID."]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current value of clock CLOCK_ID and store it in TP."]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set clock CLOCK_ID to value TP."]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return clock ID for CPU-time clock."]
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create new per-process timer using CLOCK_ID."]
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete timer TIMERID."]
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current value of timer TIMERID and store it in VALUE."]
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get expiration overrun for timer TIMERID."]
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set TS to calendar time based in time base BASE."]
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[doc = " Calling environment, plus possibly a saved signal mask."]
#[repr(C)]
#[derive(Debug)]
pub struct __jmp_buf_tag {
    #[doc = " Calling environment."]
    pub __jmpbuf: __jmp_buf,
    #[doc = " Saved the signal mask?"]
    pub __mask_was_saved: ::std::os::raw::c_int,
    #[doc = " Saved signal mask."]
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = 1;
#[doc = " Detach state."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = 0;
#[doc = " Mutex types."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = 1;
#[doc = " Robust mutex or not flags."]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = 2;
#[doc = " Mutex protocols."]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = 1;
#[doc = " Scheduler inheritance."]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = 1;
#[doc = " Scope handling."]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = 1;
#[doc = " Process shared or private flag."]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[doc = " Cleanup buffers"]
#[repr(C)]
#[derive(Debug)]
pub struct _pthread_cleanup_buffer {
    #[doc = " Function to call."]
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    #[doc = " Its argument."]
    pub __arg: *mut ::std::os::raw::c_void,
    #[doc = " Saved cancellation type."]
    pub __canceltype: ::std::os::raw::c_int,
    #[doc = " Chaining of cleanup functions."]
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = 1;
#[doc = " Cancellation"]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a new thread, starting with execution of START-ROUTINE\ngetting passed ARG.  Creation attributed come from ATTR.  The new\nhandle is stored in *NEWTHREAD."]
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Terminate calling thread.\n\nThe registered cleanup handlers are called via exception handling\nso we cannot mark this function with __THROW."]
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    #[doc = " Make calling thread wait for termination of the thread TH.  The\nexit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN\nis not NULL.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicate that the thread TH is never to be joined with PTHREAD_JOIN.\nThe resources of TH will therefore be freed immediately when it\nterminates, instead of waiting for another thread to perform PTHREAD_JOIN\non it."]
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtain the identifier of the current thread."]
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    #[doc = " Compare two thread identifiers."]
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize thread attribute *ATTR with default attributes\n(detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,\nno user-provided stack)."]
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy thread attribute *ATTR."]
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get detach state attribute."]
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set detach state attribute."]
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the size of the guard area created for stack overflow protection."]
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the size of the guard area created for stack overflow protection."]
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *PARAM the scheduling parameters of *ATTR."]
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling parameters (priority, etc) in *ATTR according to PARAM."]
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *POLICY the scheduling policy of *ATTR."]
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling policy in *ATTR according to POLICY."]
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *INHERIT the scheduling inheritance mode of *ATTR."]
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling inheritance mode in *ATTR according to INHERIT."]
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *SCOPE the scheduling contention scope of *ATTR."]
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set scheduling contention scope in *ATTR according to SCOPE."]
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the previously set address for the stack."]
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the starting address of the stack of the thread to be created.\nDepending on whether the stack grows up or down the value must either\nbe higher or lower than all the address in the memory block.  The\nminimal size of the block must be PTHREAD_STACK_MIN."]
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the currently used minimal stack size."]
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add information about the minimum stack size needed for the thread\nto be started.  This size must never be less than PTHREAD_STACK_MIN\nand must also not exceed the system limits."]
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the previously set address for the stack."]
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The following two interfaces are intended to replace the last two.  They\nrequire setting the address as well as the size since only setting the\naddress will make the implementation on some architectures impossible."]
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the scheduling parameters for TARGET_THREAD according to POLICY\nand *PARAM."]
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD."]
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the scheduling priority for TARGET_THREAD."]
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Guarantee that the initialization function INIT_ROUTINE will be called\nonly once, even if pthread_once is executed several times with the\nsame ONCE_CONTROL argument. ONCE_CONTROL must point to a static or\nextern variable initialized to PTHREAD_ONCE_INIT.\n\nThe initialization functions might throw exception which is why\nthis function is not marked with __THROW."]
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set cancellability state of current thread to STATE, returning old\nstate in *OLDSTATE if OLDSTATE is not NULL."]
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set cancellation state of current thread to TYPE, returning the old\ntype in *OLDTYPE if OLDTYPE is not NULL."]
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cancel THREAD immediately or at the next possibility."]
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Test for pending cancellation for the current thread and terminate\nthe thread as per pthread_exit(PTHREAD_CANCELED) if it has been\ncancelled."]
    pub fn pthread_testcancel();
}
#[doc = " Cancellation handling with integration into exception handling."]
#[repr(C)]
#[derive(Debug)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[doc = " Structure to hold the cleanup handler information."]
#[repr(C)]
#[derive(Debug)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    #[doc = " Internal interface to initiate cleanup."]
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a mutex."]
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a mutex."]
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try locking a mutex."]
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lock a mutex."]
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unlock a mutex."]
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the priority ceiling of MUTEX."]
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the priority ceiling of MUTEX to PRIOCEILING, return old\npriority ceiling value in *OLD_CEILING."]
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Declare the state protected by MUTEX as consistent."]
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize mutex attribute object ATTR with default attributes\n(kind is PTHREAD_MUTEX_TIMED_NP)."]
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy mutex attribute object ATTR."]
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the process-shared flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the process-shared flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *KIND the mutex kind attribute in *ATTR."]
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,\nPTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or\nPTHREAD_MUTEX_DEFAULT)."]
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *PROTOCOL the mutex protocol attribute in *ATTR."]
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the mutex protocol attribute in *ATTR to PROTOCOL (either\nPTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT)."]
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR."]
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the mutex prioceiling attribute in *ATTR to PRIOCEILING."]
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the robustness flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the robustness flag of the mutex attribute ATTR."]
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize read-write lock RWLOCK using attributes ATTR, or use\nthe default values if later is NULL."]
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy read-write lock RWLOCK."]
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Acquire read lock for RWLOCK."]
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to acquire read lock for RWLOCK."]
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Acquire write lock for RWLOCK."]
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to acquire write lock for RWLOCK."]
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unlock RWLOCK."]
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize attribute object ATTR with default values."]
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy attribute object ATTR."]
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return current setting of process-shared attribute of ATTR in PSHARED."]
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set process-shared attribute of ATTR to PSHARED."]
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return current setting of reader/writer preference."]
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set reader/write preference."]
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize condition variable COND using attributes ATTR, or use\nthe default values if later is NULL."]
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy condition variable COND."]
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wake up one thread waiting for condition variable COND."]
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wake up all threads waiting for condition variables COND."]
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for condition variable COND to be signaled or broadcast.\nMUTEX is assumed to be locked before.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize condition variable attribute ATTR."]
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy condition variable attribute ATTR."]
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the process-shared flag of the condition variable attribute ATTR."]
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the process-shared flag of the condition variable attribute ATTR."]
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the clock selected for the condition variable attribute ATTR."]
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the clock selected for the condition variable attribute ATTR."]
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can\nbe shared between different processes."]
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy the spinlock LOCK."]
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait until spinlock LOCK is retrieved."]
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to lock spinlock LOCK."]
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release spinlock LOCK."]
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize BARRIER with the attributes in ATTR.  The barrier is\nopened when COUNT waiters arrived."]
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a previously dynamically initialized barrier BARRIER."]
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait on barrier BARRIER."]
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize barrier attribute ATTR."]
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy previously dynamically initialized barrier attribute ATTR."]
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the process-shared flag of the barrier attribute ATTR."]
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the process-shared flag of the barrier attribute ATTR."]
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a key value identifying a location in the thread-specific\ndata area.  Each thread maintains a distinct thread-specific data\narea.  DESTR_FUNCTION, if non-NULL, is called with the value\nassociated to that key when the key is destroyed.\nDESTR_FUNCTION is not called if the value associated is NULL when\nthe key is destroyed."]
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy KEY."]
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return current value of the thread-specific data slot identified by KEY."]
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Store POINTER in the thread-specific data slot identified by KEY."]
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get ID of CPU-time clock for thread THREAD_ID."]
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Install handlers to be called when a new process is created with FORK.\nThe PREPARE handler is called in the parent process just before performing\nFORK. The PARENT handler is called in the parent process just after FORK.\nThe CHILD handler is called in the child process.  Each of the three\nhandlers can be NULL, meaning that no handler needs to be called at that\npoint.\nPTHREAD_ATFORK can be called several times, in which case the PREPARE\nhandlers are called in LIFO order (last added with PTHREAD_ATFORK,\nfirst called before FORK), and the PARENT and CHILD handlers are called\nin FIFO (first added, first called)."]
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Define 'max_align_t' to match the GCC definition."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type caa_cycles_t = u64;
#[doc = " The __hp() macro casts the void pointer @x to a pointer to a structure\n containing an array of char of the specified size. This allows passing the\n @addr arguments of the following inline functions as \"m\" and \"+m\" operands\n to the assembly. The @size parameter should be a constant to support\n compilers such as clang which do not support VLA. Create typedefs because\n C++ does not allow types be defined in casts."]
#[repr(C)]
#[derive(Debug)]
pub struct __hp_1 {
    pub v: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout___hp_1() {
    const UNINIT: ::std::mem::MaybeUninit<__hp_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__hp_1>(),
        1usize,
        concat!("Size of: ", stringify!(__hp_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__hp_1>(),
        1usize,
        concat!("Alignment of ", stringify!(__hp_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__hp_1), "::", stringify!(v))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __hp_2 {
    pub v: [::std::os::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout___hp_2() {
    const UNINIT: ::std::mem::MaybeUninit<__hp_2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__hp_2>(),
        2usize,
        concat!("Size of: ", stringify!(__hp_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__hp_2>(),
        1usize,
        concat!("Alignment of ", stringify!(__hp_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__hp_2), "::", stringify!(v))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __hp_4 {
    pub v: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___hp_4() {
    const UNINIT: ::std::mem::MaybeUninit<__hp_4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__hp_4>(),
        4usize,
        concat!("Size of: ", stringify!(__hp_4))
    );
    assert_eq!(
        ::std::mem::align_of::<__hp_4>(),
        1usize,
        concat!("Alignment of ", stringify!(__hp_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__hp_4), "::", stringify!(v))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct __hp_8 {
    pub v: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___hp_8() {
    const UNINIT: ::std::mem::MaybeUninit<__hp_8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__hp_8>(),
        8usize,
        concat!("Size of: ", stringify!(__hp_8))
    );
    assert_eq!(
        ::std::mem::align_of::<__hp_8>(),
        1usize,
        concat!("Alignment of ", stringify!(__hp_8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(__hp_8), "::", stringify!(v))
    );
}
extern "C" {
    pub fn rcu_dereference_sym(p: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rcu_cmpxchg_pointer_sym(
        p: *mut *mut ::std::os::raw::c_void,
        old: *mut ::std::os::raw::c_void,
        _new: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rcu_xchg_pointer_sym(
        p: *mut *mut ::std::os::raw::c_void,
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Note: rcu_set_pointer_sym returns @v because we don't want to break\n the ABI. At the API level, rcu_set_pointer() now returns void. Use of\n the return value is therefore deprecated, and will cause a build\n error."]
    pub fn rcu_set_pointer_sym(
        p: *mut *mut ::std::os::raw::c_void,
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " urcu-poll.h\n\n Userspace RCU polling header\n\n Copyright (c) 2023 Mathieu Desnoyers <mathieu.desnoyers@efficios.com>\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA"]
#[repr(C)]
#[derive(Debug)]
pub struct urcu_gp_poll_state {
    pub grace_period_id: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_urcu_gp_poll_state() {
    const UNINIT: ::std::mem::MaybeUninit<urcu_gp_poll_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<urcu_gp_poll_state>(),
        8usize,
        concat!("Size of: ", stringify!(urcu_gp_poll_state))
    );
    assert_eq!(
        ::std::mem::align_of::<urcu_gp_poll_state>(),
        8usize,
        concat!("Alignment of ", stringify!(urcu_gp_poll_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grace_period_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(urcu_gp_poll_state),
            "::",
            stringify!(grace_period_id)
        )
    );
}
extern "C" {
    #[doc = " library wrappers to be used by non-LGPL compatible source code.\n See LGPL-only urcu/static/pointer.h for documentation."]
    pub fn urcu_memb_read_lock();
}
extern "C" {
    pub fn urcu_memb_read_unlock();
}
extern "C" {
    pub fn urcu_memb_read_ongoing() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn urcu_memb_synchronize_rcu();
}
extern "C" {
    #[doc = " RCU grace period polling API."]
    pub fn urcu_memb_start_poll_synchronize_rcu() -> urcu_gp_poll_state;
}
extern "C" {
    pub fn urcu_memb_poll_state_synchronize_rcu(state: urcu_gp_poll_state) -> bool;
}
extern "C" {
    #[doc = " Reader thread registration."]
    pub fn urcu_memb_register_thread();
}
extern "C" {
    pub fn urcu_memb_unregister_thread();
}
extern "C" {
    #[doc = " Explicit rcu initialization, for \"early\" use within library constructors."]
    pub fn urcu_memb_init();
}
pub const cds_wfcq_ret_CDS_WFCQ_RET_WOULDBLOCK: cds_wfcq_ret = -1;
pub const cds_wfcq_ret_CDS_WFCQ_RET_DEST_EMPTY: cds_wfcq_ret = 0;
pub const cds_wfcq_ret_CDS_WFCQ_RET_DEST_NON_EMPTY: cds_wfcq_ret = 1;
pub const cds_wfcq_ret_CDS_WFCQ_RET_SRC_EMPTY: cds_wfcq_ret = 2;
pub type cds_wfcq_ret = ::std::os::raw::c_int;
pub const cds_wfcq_state_CDS_WFCQ_STATE_LAST: cds_wfcq_state = 1;
pub type cds_wfcq_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct cds_wfcq_node {
    pub next: *mut cds_wfcq_node,
}
#[test]
fn bindgen_test_layout_cds_wfcq_node() {
    const UNINIT: ::std::mem::MaybeUninit<cds_wfcq_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cds_wfcq_node>(),
        8usize,
        concat!("Size of: ", stringify!(cds_wfcq_node))
    );
    assert_eq!(
        ::std::mem::align_of::<cds_wfcq_node>(),
        8usize,
        concat!("Alignment of ", stringify!(cds_wfcq_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_wfcq_node),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Do not put head and tail on the same cache-line if concurrent\n enqueue/dequeue are expected from many CPUs. This eliminates\n false-sharing between enqueue and dequeue."]
#[repr(C)]
#[derive(Debug)]
pub struct __cds_wfcq_head {
    pub node: cds_wfcq_node,
}
#[test]
fn bindgen_test_layout___cds_wfcq_head() {
    const UNINIT: ::std::mem::MaybeUninit<__cds_wfcq_head> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cds_wfcq_head>(),
        8usize,
        concat!("Size of: ", stringify!(__cds_wfcq_head))
    );
    assert_eq!(
        ::std::mem::align_of::<__cds_wfcq_head>(),
        8usize,
        concat!("Alignment of ", stringify!(__cds_wfcq_head))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cds_wfcq_head),
            "::",
            stringify!(node)
        )
    );
}
#[repr(C)]
pub struct cds_wfcq_head {
    pub node: cds_wfcq_node,
    pub lock: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_cds_wfcq_head() {
    const UNINIT: ::std::mem::MaybeUninit<cds_wfcq_head> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cds_wfcq_head>(),
        48usize,
        concat!("Size of: ", stringify!(cds_wfcq_head))
    );
    assert_eq!(
        ::std::mem::align_of::<cds_wfcq_head>(),
        8usize,
        concat!("Alignment of ", stringify!(cds_wfcq_head))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_wfcq_head),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_wfcq_head),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
pub struct cds_wfcq_head_ptr_t {
    pub _h: __BindgenUnionField<*mut __cds_wfcq_head>,
    pub h: __BindgenUnionField<*mut cds_wfcq_head>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_cds_wfcq_head_ptr_t() {
    const UNINIT: ::std::mem::MaybeUninit<cds_wfcq_head_ptr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cds_wfcq_head_ptr_t>(),
        8usize,
        concat!("Size of: ", stringify!(cds_wfcq_head_ptr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cds_wfcq_head_ptr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cds_wfcq_head_ptr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_wfcq_head_ptr_t),
            "::",
            stringify!(_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_wfcq_head_ptr_t),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cds_wfcq_tail {
    pub p: *mut cds_wfcq_node,
}
#[test]
fn bindgen_test_layout_cds_wfcq_tail() {
    const UNINIT: ::std::mem::MaybeUninit<cds_wfcq_tail> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cds_wfcq_tail>(),
        8usize,
        concat!("Size of: ", stringify!(cds_wfcq_tail))
    );
    assert_eq!(
        ::std::mem::align_of::<cds_wfcq_tail>(),
        8usize,
        concat!("Alignment of ", stringify!(cds_wfcq_tail))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_wfcq_tail),
            "::",
            stringify!(p)
        )
    );
}
extern "C" {
    #[doc = " cds_wfcq_node_init: initialize wait-free queue node."]
    pub fn cds_wfcq_node_init(node: *mut cds_wfcq_node);
}
extern "C" {
    #[doc = " cds_wfcq_init: initialize wait-free queue. Pair with\n cds_wfcq_destroy()."]
    pub fn cds_wfcq_init(head: *mut cds_wfcq_head, tail: *mut cds_wfcq_tail);
}
extern "C" {
    #[doc = " cds_wfcq_destroy: destroy wait-free queue. Pair with\n cds_wfcq_init()."]
    pub fn cds_wfcq_destroy(head: *mut cds_wfcq_head, tail: *mut cds_wfcq_tail);
}
extern "C" {
    #[doc = " __cds_wfcq_init: initialize wait-free queue (without lock). Don't\n pair with any destroy function."]
    pub fn __cds_wfcq_init(head: *mut __cds_wfcq_head, tail: *mut cds_wfcq_tail);
}
extern "C" {
    #[doc = " cds_wfcq_empty: return whether wait-free queue is empty.\n\n No memory barrier is issued. No mutual exclusion is required."]
    pub fn cds_wfcq_empty(head: cds_wfcq_head_ptr_t, tail: *mut cds_wfcq_tail) -> bool;
}
extern "C" {
    #[doc = " cds_wfcq_dequeue_lock: take the dequeue mutual exclusion lock."]
    pub fn cds_wfcq_dequeue_lock(head: *mut cds_wfcq_head, tail: *mut cds_wfcq_tail);
}
extern "C" {
    #[doc = " cds_wfcq_dequeue_unlock: release the dequeue mutual exclusion lock."]
    pub fn cds_wfcq_dequeue_unlock(head: *mut cds_wfcq_head, tail: *mut cds_wfcq_tail);
}
extern "C" {
    #[doc = " cds_wfcq_enqueue: enqueue a node into a wait-free queue.\n\n Issues a full memory barrier before enqueue. No mutual exclusion is\n required.\n\n Returns false if the queue was empty prior to adding the node.\n Returns true otherwise."]
    pub fn cds_wfcq_enqueue(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
        node: *mut cds_wfcq_node,
    ) -> bool;
}
extern "C" {
    #[doc = " cds_wfcq_dequeue_blocking: dequeue a node from a wait-free queue.\n\n Content written into the node before enqueue is guaranteed to be\n consistent, but no other memory ordering is ensured.\n It is valid to reuse and free a dequeued node immediately.\n Mutual exclusion with cds_wfcq_dequeue_blocking and dequeue lock is\n ensured."]
    pub fn cds_wfcq_dequeue_blocking(
        head: *mut cds_wfcq_head,
        tail: *mut cds_wfcq_tail,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " cds_wfcq_dequeue_with_state_blocking: dequeue with state.\n\n Same as cds_wfcq_dequeue_blocking, but saves whether dequeueing the\n last node of the queue into state (CDS_WFCQ_STATE_LAST)."]
    pub fn cds_wfcq_dequeue_with_state_blocking(
        head: *mut cds_wfcq_head,
        tail: *mut cds_wfcq_tail,
        state: *mut ::std::os::raw::c_int,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " cds_wfcq_splice_blocking: enqueue all src_q nodes at the end of dest_q.\n\n Dequeue all nodes from src_q.\n dest_q must be already initialized.\n Content written into the node before enqueue is guaranteed to be\n consistent, but no other memory ordering is ensured.\n Mutual exclusion with cds_wfcq_dequeue_blocking and dequeue lock is\n ensured.\n\n Returns enum cds_wfcq_ret which indicates the state of the src or\n dest queue."]
    pub fn cds_wfcq_splice_blocking(
        dest_q_head: *mut cds_wfcq_head,
        dest_q_tail: *mut cds_wfcq_tail,
        src_q_head: *mut cds_wfcq_head,
        src_q_tail: *mut cds_wfcq_tail,
    ) -> cds_wfcq_ret;
}
extern "C" {
    #[doc = " __cds_wfcq_dequeue_blocking: dequeue a node from a wait-free queue.\n\n Content written into the node before enqueue is guaranteed to be\n consistent, but no other memory ordering is ensured.\n It is valid to reuse and free a dequeued node immediately.\n Dequeue/splice/iteration mutual exclusion should be ensured by the\n caller."]
    pub fn __cds_wfcq_dequeue_blocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " __cds_wfcq_dequeue_with_state_blocking: dequeue with state.\n\n Same as __cds_wfcq_dequeue_blocking, but saves whether dequeueing the\n last node of the queue into state (CDS_WFCQ_STATE_LAST)."]
    pub fn __cds_wfcq_dequeue_with_state_blocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
        state: *mut ::std::os::raw::c_int,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " __cds_wfcq_dequeue_nonblocking: dequeue a node from a wait-free queue.\n\n Same as __cds_wfcq_dequeue_blocking, but returns CDS_WFCQ_WOULDBLOCK\n if it needs to block."]
    pub fn __cds_wfcq_dequeue_nonblocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " __cds_wfcq_dequeue_with_state_blocking: dequeue with state.\n\n Same as __cds_wfcq_dequeue_nonblocking, but saves whether dequeueing\n the last node of the queue into state (CDS_WFCQ_STATE_LAST)."]
    pub fn __cds_wfcq_dequeue_with_state_nonblocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
        state: *mut ::std::os::raw::c_int,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " __cds_wfcq_splice_blocking: enqueue all src_q nodes at the end of dest_q.\n\n Dequeue all nodes from src_q.\n dest_q must be already initialized.\n Mutual exclusion for src_q should be ensured by the caller as\n specified in the \"Synchronisation table\".\n Returns enum cds_wfcq_ret which indicates the state of the src or\n dest queue. Never returns CDS_WFCQ_RET_WOULDBLOCK."]
    pub fn __cds_wfcq_splice_blocking(
        dest_q_head: cds_wfcq_head_ptr_t,
        dest_q_tail: *mut cds_wfcq_tail,
        src_q_head: cds_wfcq_head_ptr_t,
        src_q_tail: *mut cds_wfcq_tail,
    ) -> cds_wfcq_ret;
}
extern "C" {
    #[doc = " __cds_wfcq_splice_nonblocking: enqueue all src_q nodes at the end of dest_q.\n\n Same as __cds_wfcq_splice_blocking, but returns\n CDS_WFCQ_RET_WOULDBLOCK if it needs to block."]
    pub fn __cds_wfcq_splice_nonblocking(
        dest_q_head: cds_wfcq_head_ptr_t,
        dest_q_tail: *mut cds_wfcq_tail,
        src_q_head: cds_wfcq_head_ptr_t,
        src_q_tail: *mut cds_wfcq_tail,
    ) -> cds_wfcq_ret;
}
extern "C" {
    #[doc = " __cds_wfcq_first_blocking: get first node of a queue, without dequeuing.\n\n Content written into the node before enqueue is guaranteed to be\n consistent, but no other memory ordering is ensured.\n Dequeue/splice/iteration mutual exclusion should be ensured by the\n caller.\n\n Used by for-like iteration macros:\n __cds_wfcq_for_each_blocking()\n __cds_wfcq_for_each_blocking_safe()\n\n Returns NULL if queue is empty, first node otherwise."]
    pub fn __cds_wfcq_first_blocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " __cds_wfcq_first_nonblocking: get first node of a queue, without dequeuing.\n\n Same as __cds_wfcq_first_blocking, but returns CDS_WFCQ_WOULDBLOCK if\n it needs to block."]
    pub fn __cds_wfcq_first_nonblocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " __cds_wfcq_next_blocking: get next node of a queue, without dequeuing.\n\n Content written into the node before enqueue is guaranteed to be\n consistent, but no other memory ordering is ensured.\n Dequeue/splice/iteration mutual exclusion should be ensured by the\n caller.\n\n Used by for-like iteration macros:\n __cds_wfcq_for_each_blocking()\n __cds_wfcq_for_each_blocking_safe()\n\n Returns NULL if reached end of queue, non-NULL next queue node\n otherwise."]
    pub fn __cds_wfcq_next_blocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
        node: *mut cds_wfcq_node,
    ) -> *mut cds_wfcq_node;
}
extern "C" {
    #[doc = " __cds_wfcq_next_blocking: get next node of a queue, without dequeuing.\n\n Same as __cds_wfcq_next_blocking, but returns CDS_WFCQ_WOULDBLOCK if\n it needs to block."]
    pub fn __cds_wfcq_next_nonblocking(
        head: cds_wfcq_head_ptr_t,
        tail: *mut cds_wfcq_tail,
        node: *mut cds_wfcq_node,
    ) -> *mut cds_wfcq_node;
}
#[doc = " Note that struct call_rcu_data is opaque to callers."]
#[repr(C)]
#[derive(Debug)]
pub struct call_rcu_data {
    _unused: [u8; 0],
}
#[doc = " The rcu_head data structure is placed in the structure to be freed\n via call_rcu()."]
#[repr(C)]
#[derive(Debug)]
pub struct rcu_head {
    pub next: cds_wfcq_node,
    pub func: ::std::option::Option<unsafe extern "C" fn(head: *mut rcu_head)>,
}
#[test]
fn bindgen_test_layout_rcu_head() {
    const UNINIT: ::std::mem::MaybeUninit<rcu_head> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcu_head>(),
        16usize,
        concat!("Size of: ", stringify!(rcu_head))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_head>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_head))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_head),
            "::",
            stringify!(func)
        )
    );
}
extern "C" {
    pub fn urcu_memb_call_rcu(
        head: *mut rcu_head,
        func: ::std::option::Option<unsafe extern "C" fn(head: *mut rcu_head)>,
    );
}
extern "C" {
    pub fn urcu_memb_create_call_rcu_data(
        flags: ::std::os::raw::c_ulong,
        cpu_affinity: ::std::os::raw::c_int,
    ) -> *mut call_rcu_data;
}
extern "C" {
    pub fn urcu_memb_call_rcu_data_free(crdp: *mut call_rcu_data);
}
extern "C" {
    pub fn urcu_memb_get_default_call_rcu_data() -> *mut call_rcu_data;
}
extern "C" {
    pub fn urcu_memb_get_cpu_call_rcu_data(cpu: ::std::os::raw::c_int) -> *mut call_rcu_data;
}
extern "C" {
    pub fn urcu_memb_get_thread_call_rcu_data() -> *mut call_rcu_data;
}
extern "C" {
    pub fn urcu_memb_get_call_rcu_data() -> *mut call_rcu_data;
}
extern "C" {
    pub fn urcu_memb_get_call_rcu_thread(crdp: *mut call_rcu_data) -> pthread_t;
}
extern "C" {
    pub fn urcu_memb_set_thread_call_rcu_data(crdp: *mut call_rcu_data);
}
extern "C" {
    pub fn urcu_memb_set_cpu_call_rcu_data(
        cpu: ::std::os::raw::c_int,
        crdp: *mut call_rcu_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn urcu_memb_create_all_cpu_call_rcu_data(
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn urcu_memb_free_all_cpu_call_rcu_data();
}
extern "C" {
    pub fn urcu_memb_call_rcu_before_fork();
}
extern "C" {
    pub fn urcu_memb_call_rcu_after_fork_parent();
}
extern "C" {
    pub fn urcu_memb_call_rcu_after_fork_child();
}
extern "C" {
    pub fn urcu_memb_barrier();
}
extern "C" {
    pub fn urcu_memb_defer_rcu(
        fct: ::std::option::Option<unsafe extern "C" fn(p: *mut ::std::os::raw::c_void)>,
        p: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn urcu_memb_defer_register_thread() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn urcu_memb_defer_unregister_thread();
}
extern "C" {
    pub fn urcu_memb_defer_barrier();
}
extern "C" {
    pub fn urcu_memb_defer_barrier_thread();
}
#[repr(C)]
#[derive(Debug)]
pub struct urcu_atfork {
    pub before_fork:
        ::std::option::Option<unsafe extern "C" fn(priv_: *mut ::std::os::raw::c_void)>,
    pub after_fork_parent:
        ::std::option::Option<unsafe extern "C" fn(priv_: *mut ::std::os::raw::c_void)>,
    pub after_fork_child:
        ::std::option::Option<unsafe extern "C" fn(priv_: *mut ::std::os::raw::c_void)>,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_urcu_atfork() {
    const UNINIT: ::std::mem::MaybeUninit<urcu_atfork> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<urcu_atfork>(),
        32usize,
        concat!("Size of: ", stringify!(urcu_atfork))
    );
    assert_eq!(
        ::std::mem::align_of::<urcu_atfork>(),
        8usize,
        concat!("Alignment of ", stringify!(urcu_atfork))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).before_fork) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(urcu_atfork),
            "::",
            stringify!(before_fork)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).after_fork_parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(urcu_atfork),
            "::",
            stringify!(after_fork_parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).after_fork_child) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(urcu_atfork),
            "::",
            stringify!(after_fork_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(urcu_atfork),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn urcu_memb_register_rculfhash_atfork(atfork: *mut urcu_atfork);
}
extern "C" {
    pub fn urcu_memb_unregister_rculfhash_atfork(atfork: *mut urcu_atfork);
}
#[repr(C)]
#[derive(Debug)]
pub struct rcu_flavor_struct {
    pub read_lock: ::std::option::Option<unsafe extern "C" fn()>,
    pub read_unlock: ::std::option::Option<unsafe extern "C" fn()>,
    pub read_ongoing: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub read_quiescent_state: ::std::option::Option<unsafe extern "C" fn()>,
    pub update_call_rcu: ::std::option::Option<
        unsafe extern "C" fn(
            head: *mut rcu_head,
            func: ::std::option::Option<unsafe extern "C" fn(head: *mut rcu_head)>,
        ),
    >,
    pub update_synchronize_rcu: ::std::option::Option<unsafe extern "C" fn()>,
    pub update_defer_rcu: ::std::option::Option<
        unsafe extern "C" fn(
            fct: ::std::option::Option<unsafe extern "C" fn(p: *mut ::std::os::raw::c_void)>,
            p: *mut ::std::os::raw::c_void,
        ),
    >,
    pub thread_offline: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_online: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_thread: ::std::option::Option<unsafe extern "C" fn()>,
    pub unregister_thread: ::std::option::Option<unsafe extern "C" fn()>,
    pub barrier: ::std::option::Option<unsafe extern "C" fn()>,
    pub register_rculfhash_atfork:
        ::std::option::Option<unsafe extern "C" fn(atfork: *mut urcu_atfork)>,
    pub unregister_rculfhash_atfork:
        ::std::option::Option<unsafe extern "C" fn(atfork: *mut urcu_atfork)>,
    pub update_start_poll_synchronize_rcu:
        ::std::option::Option<unsafe extern "C" fn() -> urcu_gp_poll_state>,
    pub update_poll_state_synchronize_rcu:
        ::std::option::Option<unsafe extern "C" fn(state: urcu_gp_poll_state) -> bool>,
}
#[test]
fn bindgen_test_layout_rcu_flavor_struct() {
    const UNINIT: ::std::mem::MaybeUninit<rcu_flavor_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rcu_flavor_struct>(),
        128usize,
        concat!("Size of: ", stringify!(rcu_flavor_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_flavor_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_flavor_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(read_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_unlock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(read_unlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_ongoing) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(read_ongoing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_quiescent_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(read_quiescent_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_call_rcu) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(update_call_rcu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_synchronize_rcu) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(update_synchronize_rcu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_defer_rcu) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(update_defer_rcu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_offline) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(thread_offline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_online) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(thread_online)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_thread) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(register_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_thread) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(unregister_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).barrier) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(barrier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_rculfhash_atfork) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(register_rculfhash_atfork)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unregister_rculfhash_atfork) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(unregister_rculfhash_atfork)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).update_start_poll_synchronize_rcu) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(update_start_poll_synchronize_rcu)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).update_poll_state_synchronize_rcu) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_flavor_struct),
            "::",
            stringify!(update_poll_state_synchronize_rcu)
        )
    );
}
extern "C" {
    pub static urcu_memb_flavor: rcu_flavor_struct;
}
extern "C" {
    pub fn urcu_qsbr_read_ongoing() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn urcu_qsbr_quiescent_state();
}
extern "C" {
    pub fn urcu_qsbr_thread_offline();
}
extern "C" {
    pub fn urcu_qsbr_thread_online();
}
extern "C" {
    pub fn urcu_qsbr_synchronize_rcu();
}
extern "C" {
    #[doc = " RCU grace period polling API."]
    pub fn urcu_qsbr_start_poll_synchronize_rcu() -> urcu_gp_poll_state;
}
extern "C" {
    pub fn urcu_qsbr_poll_state_synchronize_rcu(state: urcu_gp_poll_state) -> bool;
}
extern "C" {
    #[doc = " Reader thread registration."]
    pub fn urcu_qsbr_register_thread();
}
extern "C" {
    pub fn urcu_qsbr_unregister_thread();
}
extern "C" {
    #[doc = " library wrappers to be used by non-LGPL compatible source code.\n See LGPL-only urcu/static/pointer.h for documentation."]
    pub fn urcu_bp_read_lock();
}
extern "C" {
    pub fn urcu_bp_read_unlock();
}
extern "C" {
    pub fn urcu_bp_read_ongoing() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn urcu_bp_dereference_sym(p: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn urcu_bp_cmpxchg_pointer_sym(
        p: *mut *mut ::std::os::raw::c_void,
        old: *mut ::std::os::raw::c_void,
        _new: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn urcu_bp_xchg_pointer_sym(
        p: *mut *mut ::std::os::raw::c_void,
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn urcu_bp_set_pointer_sym(
        p: *mut *mut ::std::os::raw::c_void,
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn urcu_bp_synchronize_rcu();
}
extern "C" {
    #[doc = " RCU grace period polling API."]
    pub fn urcu_bp_start_poll_synchronize_rcu() -> urcu_gp_poll_state;
}
extern "C" {
    pub fn urcu_bp_poll_state_synchronize_rcu(state: urcu_gp_poll_state) -> bool;
}
extern "C" {
    #[doc = " urcu_bp_before_fork, urcu_bp_after_fork_parent and urcu_bp_after_fork_child\n should be called around fork() system calls when the child process is not\n expected to immediately perform an exec(). For pthread users, see\n pthread_atfork(3)."]
    pub fn urcu_bp_before_fork();
}
extern "C" {
    pub fn urcu_bp_after_fork_parent();
}
extern "C" {
    pub fn urcu_bp_after_fork_child();
}
extern "C" {
    #[doc = " In the bulletproof version, thread registration is performed lazily,\n but it can be forced by issuing an explicit urcu_bp_register_thread()."]
    pub fn urcu_bp_register_thread();
}
#[doc = " 13 = __LC_LAST."]
#[repr(C)]
#[derive(Debug)]
pub struct __locale_data {
    pub _address: u8,
}
